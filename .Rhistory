# 1. Normal and tangential acceleration
a_mag1 = sqrt(a_T^2 + a_N^2)
# plot(a_mag1)
amag2 = sqrt(polAccel[,1]^2 + polAccel[,2]^2)
# plot(amag2, type = 'l')
# plot(polVelocity[,1])
########################################
###########################################
# anther acceleration
anthVelocity = cbind(antherPoll$anthx.1.abs.vel, antherPoll$anthy.1.abs.vel)
anthSpeed = antherPoll$anthspeed
# plot(anthSpeed)
tme = antherPoll$tme
anthAccel = data.frame(rbind(c(NA, NA), apply(anthVelocity, MARGIN = 2, FUN = diff))) * fps
# par(mfrow =c(2,2))
# # plot(anthAccel[,1], x = antherPoll$tme, type = 'l') # calculated
# plot(anthAccel[,2], x = antherPoll$tme, type = 'l')
# unit tangent vector
T_t = anthVelocity / anthSpeed
DT = data.frame(rbind(c(NA, NA), apply(T_t, MARGIN = 2, FUN = diff))) * fps
NormDT = sqrt(DT[,1]^2 + DT[,2]^2)
Curvature = NormDT / anthSpeed
# compute a_N (normal acceleration) and a_T (tangential acceleration)
# a_T = ds/dt
a_T =  c(NA, diff(anthSpeed) * fps)
a_T_anth = a_T
N_t = data.frame(t(sapply(1:nrow(DT), FUN = function(x) unlist(DT[x, ] / NormDT[x]))))
# plot(a_T, type = "l", ylim = c(-3000, 3000))
# a_N = speed^2 * curvature
a_N = anthSpeed^2 * Curvature
# check total accel by adding normal and tangential accelerations
# a_total = a_T * T_t + a_N * N_t
a_total = as.data.frame(t(sapply(X = 1:nrow(anthAccel), FUN  = function(x) a_T[x] * T_t[x, ] + a_N[x] * N_t[x,] )))
# plot(a_total) # includes both x and y coordinates
# plot(anthAccel)
# par(mfrow = c(2,2))
# plot(unlist(a_total[,1]))
# plot(unlist(a_total[,2]))
# plot(anthAccel[,1])
# plot(anthAccel[,2])
# plot(a_N)
# plot(a_T)
# par(mfrow = c(2,1))
# plot(a_T, x = tme, type = 'l')
# max(a_T, na.rm = TRUE)
# which.max(a_T)
# plot(a_T_Pol, x = tme, type = 'l')
# max(a_T_Pol, na.rm = TRUE)
# which.max(a_T_Pol)
#
tmeRoll <- seq(from = -which(antherPoll$polStart) + 1, length.out = length(tme)) / fps
dfi <- data.frame(anthSpeed, polSpeed, a_T_anth, a_T_Pol, tme,
trial = metDat$VideoName[ii],
tmeStart = antherPoll$polStart,
tmeEnd = antherPoll$polEnd,
centeredTime = tmeRoll)
newDF <- rbind(newDF,dfi)
print(ii)
}
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages <- c("ggplot2", "scales", "multcomp", "plyr", "car", "lme4", "signal", "reshape2", "viridis")
ipak(packages)
dfile <- "/Users/callinswitzer/Dropbox/ExperSummer2015/LaurelsOnly.csv"
metDat <- read.csv(dfile)
metDat <- metDat[metDat$digitizedFile!= "", ]
fps <- 5000 # frames per second
ii = 11
digdirect <- "/Users/callinswitzer/Dropbox/ExperSummer2015/AllLaurelsDigitizations/"
newDF <- data.frame()
for(ii in 1:nrow(metDat)){
# ignore ii ==7, because the video started too late
if(ii == 7) next
ddfile <- paste0(digdirect, metDat$digitizedFile[ii])
dp <- read.csv(ddfile)
# calibrate locations, based on digitized pin or other object
# calibration points
pin <- data.frame(dp$pt1_cam1_X, dp$pt1_cam1_Y, dp$pt2_cam1_X, dp$pt2_cam1_Y)
pin <- pin[complete.cases(pin), ]
# get the number of pixels in the calibration
PixInPin <- (sqrt((pin$dp.pt1_cam1_X - pin$dp.pt2_cam1_X)^2 +
(pin$dp.pt1_cam1_Y-pin$dp.pt2_cam1_Y)^2)) /
metDat$CalSizeMM[ii] # to get to mm
# get anther and pollen locations
antherPoll <- data.frame(anthx = dp$pt3_cam1_X, anthy= dp$pt3_cam1_Y,
polx = dp$pt4_cam1_X, poly= dp$pt4_cam1_Y)
# get frame where pollen starts and leaves
antherPoll$polStart = 1:nrow(antherPoll) == metDat$framePollenStartedLeaving[ii]
antherPoll$polEnd = 1:nrow(antherPoll) == metDat$framePollenReleaseComplete[ii]
# gives only rows where either anth and pollen are complete
antherPoll = antherPoll[ complete.cases(antherPoll[c('anthx')]) |
complete.cases(antherPoll[c('polx')]), ]
# if x value starts to right of screen, reverse points,
# so all x values start on the left part of the screen at 0
if(lm(antherPoll[,1] ~ I(1:length( antherPoll[,1])))$coefficients[2] < 0 ){
antherPoll$anthx <- metDat[ii,'vidWidth'] - antherPoll$anthx
antherPoll$polx <- metDat[ii,'vidWidth'] - antherPoll$polx
}
# cbind data frame, to add smoothed columns
antherPoll <- data.frame(cbind(antherPoll, antherPoll))
# plot(x = antherPoll$anthx.1, y = antherPoll$anthy.1)
# plot(antherPoll$anthx.1)
# smooth with SG is based on the least-squares fitting of
# polynomials to segments of the data
# other options include smoothing splines (tend to "cut the corners" of curves)
# butterworth filters (inaccurate at endpoints)
# Kernel smoothing
x <- na.omit(antherPoll$anthy.1)
xx <- c(x[round(length(x)/ 2):1], x, x[round(length(x)):round(length(x)/ 2)])
want = c(rep(FALSE, round(length(x)/ 2)), rep(TRUE, length(x)), rep(FALSE, round(length(x)/2)))
sg <- sgolayfilt(xx, p = 3, n = 11) # Savitzky-Golay filter
# plot(xx[want], type="b", col = 'red', pch = 20)
# points(sg[want], pch = 20, type = 'o') # smoothed SG data
W = 0.99
b1 <- butter(5, W, type = 'low')
y1 <- filtfilt(b1, xx)
# points(y1[want], pch=20, col='grey')
# filter with Savitzky-Golay filter or Butterworth filter
# degree = 3, frame size = 11 points
foo = sapply(X = c("anthx.1", "anthy.1", "polx.1", "poly.1"), FUN = function(y){
#sm1 <- sgolayfilt(na.omit(antherPoll[, x]), p = 3, n = 51)
# butterworth filter
x <- na.omit(antherPoll[, y])
xx <- c(x[round(length(x)/ 2):1], x, x[round(length(x)):round(length(x)/ 2)])
want = c(rep(FALSE, round(length(x)/ 2)), rep(TRUE, length(x)), rep(FALSE, round(length(x)/2)))
W = kk # sweet spot seems to be about 0.2
b1 <- butter(5, W, type = 'low')
y1 <- filtfilt(b1, xx)
sm1 <- y1[want]
antherPoll[, y][complete.cases(antherPoll[, y])] <<- sm1
})
# add time to data frame
antherPoll$tme = 0: (nrow(antherPoll) - 1) / fps # time
# add columns with absolute position into dataframe (calculated from smoothed data)
# calculate position from starting point, not from minimum point
bar = sapply(X = c("anthx.1", "anthy.1", "polx.1", "poly.1"), FUN = function(x){
newName = paste0(x, ".abs")
tmp <- antherPoll[,x] / PixInPin / 1000
antherPoll[,newName] <<- tmp - na.omit(tmp)[1]
#antherPoll[,newName] <<- tmp - min(na.omit(tmp))
})
# add columns to show velocity, based on smoothed, absolute position
# velocity is in m/s
bat = sapply(X = c("anthx.1.abs", "anthy.1.abs", "polx.1.abs", "poly.1.abs"),
FUN = function(x){
newName = paste0(x, ".vel")
tmp <-  c(NaN, diff(antherPoll[,x])) * fps # add a NaN to beginning of data
antherPoll[,newName] <<- tmp
})
# calculate speed
antherPoll$anthspeed = sqrt(antherPoll$anthx.1.abs.vel^2 + antherPoll$anthy.1.abs.vel^2)
antherPoll$polspeed = sqrt(antherPoll$polx.1.abs.vel^2 + antherPoll$poly.1.abs.vel^2)
# plot(antherPoll$anthspeed)
###########################################
# pollen acceleration
polVelocity = cbind(antherPoll$polx.1.abs.vel, antherPoll$poly.1.abs.vel)
polSpeed = antherPoll$polspeed
# plot(polSpeed)
tme = antherPoll$tme
polAccel = data.frame(rbind(c(NA, NA), apply(polVelocity, MARGIN = 2, FUN = diff))) * fps
# par(mfrow =c(2,2))
# plot(polAccel[,1], x = antherPoll$tme, type = 'l') # calculated
# plot(polAccel[,2], x = antherPoll$tme, type = 'l')
# unit tangent vector
T_t = polVelocity / polSpeed
DT = data.frame(rbind(c(NA, NA), apply(T_t, MARGIN = 2, FUN = diff))) * fps
NormDT = sqrt(DT[,1]^2 + DT[,2]^2)
Curvature = NormDT / polSpeed
# compute a_N (normal acceleration) and a_T (tangential acceleration)
# a_T = ds/dt
a_T =  c(NA, diff(polSpeed) * fps)
N_t = data.frame(t(sapply(1:nrow(DT), FUN = function(x) unlist(DT[x, ] / NormDT[x]))))
# plot(a_T, type = "l", ylim = c(-3000, 3000))
# a_N = speed^2 * curvature
a_N = polSpeed^2 * Curvature
# check total accel by adding normal and tangential accelerations
# a_total = a_T * T_t + a_N * N_t
a_total = as.data.frame(t(sapply(X = 1:nrow(polAccel), FUN  = function(x) a_T[x] * T_t[x, ] + a_N[x] * N_t[x,] )))
# plot(a_total) # includes both x and y coordinates
# plot(polAccel)
# par(mfrow = c(2,2))
# plot(unlist(a_total[,1]))
# plot(unlist(a_total[,2]))
# plot(polAccel[,1])
# plot(polAccel[,2])
# plot(a_N)
# plot(a_T)
#
a_T_Pol = a_T
# plot(a_T, x = tme)
# plot(a_N, x = tme)
# calculate magnitude of acceleration, using two methods
# 1. Normal and tangential acceleration
a_mag1 = sqrt(a_T^2 + a_N^2)
# plot(a_mag1)
amag2 = sqrt(polAccel[,1]^2 + polAccel[,2]^2)
# plot(amag2, type = 'l')
# plot(polVelocity[,1])
########################################
###########################################
# anther acceleration
anthVelocity = cbind(antherPoll$anthx.1.abs.vel, antherPoll$anthy.1.abs.vel)
anthSpeed = antherPoll$anthspeed
# plot(anthSpeed)
tme = antherPoll$tme
anthAccel = data.frame(rbind(c(NA, NA), apply(anthVelocity, MARGIN = 2, FUN = diff))) * fps
# par(mfrow =c(2,2))
# # plot(anthAccel[,1], x = antherPoll$tme, type = 'l') # calculated
# plot(anthAccel[,2], x = antherPoll$tme, type = 'l')
# unit tangent vector
T_t = anthVelocity / anthSpeed
DT = data.frame(rbind(c(NA, NA), apply(T_t, MARGIN = 2, FUN = diff))) * fps
NormDT = sqrt(DT[,1]^2 + DT[,2]^2)
Curvature = NormDT / anthSpeed
# compute a_N (normal acceleration) and a_T (tangential acceleration)
# a_T = ds/dt
a_T =  c(NA, diff(anthSpeed) * fps)
a_T_anth = a_T
N_t = data.frame(t(sapply(1:nrow(DT), FUN = function(x) unlist(DT[x, ] / NormDT[x]))))
# plot(a_T, type = "l", ylim = c(-3000, 3000))
# a_N = speed^2 * curvature
a_N = anthSpeed^2 * Curvature
# check total accel by adding normal and tangential accelerations
# a_total = a_T * T_t + a_N * N_t
a_total = as.data.frame(t(sapply(X = 1:nrow(anthAccel), FUN  = function(x) a_T[x] * T_t[x, ] + a_N[x] * N_t[x,] )))
# plot(a_total) # includes both x and y coordinates
# plot(anthAccel)
# par(mfrow = c(2,2))
# plot(unlist(a_total[,1]))
# plot(unlist(a_total[,2]))
# plot(anthAccel[,1])
# plot(anthAccel[,2])
# plot(a_N)
# plot(a_T)
# par(mfrow = c(2,1))
# plot(a_T, x = tme, type = 'l')
# max(a_T, na.rm = TRUE)
# which.max(a_T)
# plot(a_T_Pol, x = tme, type = 'l')
# max(a_T_Pol, na.rm = TRUE)
# which.max(a_T_Pol)
#
tmeRoll <- seq(from = -which(antherPoll$polStart) + 1, length.out = length(tme)) / fps
dfi <- data.frame(anthSpeed, polSpeed, a_T_anth, a_T_Pol, tme,
trial = metDat$VideoName[ii],
tmeStart = antherPoll$polStart,
tmeEnd = antherPoll$polEnd,
centeredTime = tmeRoll)
newDF <- rbind(newDF,dfi)
print(ii)
}
antherPoll$frame <- 1:nrow(antherPoll)
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3) +
geom_point(aes(x = anthx.1, y = anthy.1, colour = frame)) +
geom_path(aes(x = anthx.1, y = anthy.1, color = frame)) +
scale_color_viridis()
ggplot((antherPoll)) +
geom_point(aes(x = polx, y = poly), colour = "grey", alpha = 0.3) +
geom_path(aes(x = polx, y = poly), color = "grey", alpha = 0.3) +
geom_point(aes(x = polx.1, y = poly.1, colour = frame)) +
geom_path(aes(x = polx.1, y = poly.1, color = frame)) +
scale_color_viridis() +
coord_fixed(ratio = 1)
plot(antherPoll$anthx, antherPoll$anthy)
points(antherPoll$anthx.1, antherPoll$anthy.1, type = 'b', pch = 20)
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3) +
geom_point(aes(x = anthx.1, y = anthy.1, colour = frame)) +
geom_path(aes(x = anthx.1, y = anthy.1, color = frame)) +
scale_color_viridis()
ggplot((antherPoll)) +
geom_point(aes(x = polx, y = poly), colour = "grey", alpha = 0.3) +
geom_path(aes(x = polx, y = poly), color = "grey", alpha = 0.3) +
geom_point(aes(x = polx.1, y = poly.1, colour = frame)) +
geom_path(aes(x = polx.1, y = poly.1, color = frame)) +
scale_color_viridis() +
coord_fixed(ratio = 1)
antherPoll$frame <- 1:nrow(antherPoll)
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3) +
geom_point(aes(x = anthx.1, y = anthy.1, colour = frame)) +
geom_path(aes(x = anthx.1, y = anthy.1, color = frame)) +
scale_color_viridis()
kk = 0.99
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3) +
geom_point(aes(x = anthx.1, y = anthy.1, colour = frame)) +
geom_path(aes(x = anthx.1, y = anthy.1, color = frame)) +
scale_color_viridis()
newDF <- data.frame()
for(ii in 1:nrow(metDat)){
# ignore ii ==7, because the video started too late
if(ii == 7) next
ddfile <- paste0(digdirect, metDat$digitizedFile[ii])
dp <- read.csv(ddfile)
# calibrate locations, based on digitized pin or other object
# calibration points
pin <- data.frame(dp$pt1_cam1_X, dp$pt1_cam1_Y, dp$pt2_cam1_X, dp$pt2_cam1_Y)
pin <- pin[complete.cases(pin), ]
# get the number of pixels in the calibration
PixInPin <- (sqrt((pin$dp.pt1_cam1_X - pin$dp.pt2_cam1_X)^2 +
(pin$dp.pt1_cam1_Y-pin$dp.pt2_cam1_Y)^2)) /
metDat$CalSizeMM[ii] # to get to mm
# get anther and pollen locations
antherPoll <- data.frame(anthx = dp$pt3_cam1_X, anthy= dp$pt3_cam1_Y,
polx = dp$pt4_cam1_X, poly= dp$pt4_cam1_Y)
# get frame where pollen starts and leaves
antherPoll$polStart = 1:nrow(antherPoll) == metDat$framePollenStartedLeaving[ii]
antherPoll$polEnd = 1:nrow(antherPoll) == metDat$framePollenReleaseComplete[ii]
# gives only rows where either anth and pollen are complete
antherPoll = antherPoll[ complete.cases(antherPoll[c('anthx')]) |
complete.cases(antherPoll[c('polx')]), ]
# if x value starts to right of screen, reverse points,
# so all x values start on the left part of the screen at 0
if(lm(antherPoll[,1] ~ I(1:length( antherPoll[,1])))$coefficients[2] < 0 ){
antherPoll$anthx <- metDat[ii,'vidWidth'] - antherPoll$anthx
antherPoll$polx <- metDat[ii,'vidWidth'] - antherPoll$polx
}
# cbind data frame, to add smoothed columns
antherPoll <- data.frame(cbind(antherPoll, antherPoll))
# plot(x = antherPoll$anthx.1, y = antherPoll$anthy.1)
# plot(antherPoll$anthx.1)
# smooth with SG is based on the least-squares fitting of
# polynomials to segments of the data
# other options include smoothing splines (tend to "cut the corners" of curves)
# butterworth filters (inaccurate at endpoints)
# Kernel smoothing
x <- na.omit(antherPoll$anthy.1)
xx <- c(x[round(length(x)/ 2):1], x, x[round(length(x)):round(length(x)/ 2)])
want = c(rep(FALSE, round(length(x)/ 2)), rep(TRUE, length(x)), rep(FALSE, round(length(x)/2)))
sg <- sgolayfilt(xx, p = 3, n = 11) # Savitzky-Golay filter
# plot(xx[want], type="b", col = 'red', pch = 20)
# points(sg[want], pch = 20, type = 'o') # smoothed SG data
W = 0.99
b1 <- butter(5, W, type = 'low')
y1 <- filtfilt(b1, xx)
# points(y1[want], pch=20, col='grey')
# filter with Savitzky-Golay filter or Butterworth filter
# degree = 3, frame size = 11 points
foo = sapply(X = c("anthx.1", "anthy.1", "polx.1", "poly.1"), FUN = function(y){
#sm1 <- sgolayfilt(na.omit(antherPoll[, x]), p = 3, n = 51)
# butterworth filter
x <- na.omit(antherPoll[, y])
xx <- c(x[round(length(x)/ 2):1], x, x[round(length(x)):round(length(x)/ 2)])
want = c(rep(FALSE, round(length(x)/ 2)), rep(TRUE, length(x)), rep(FALSE, round(length(x)/2)))
W = kk # sweet spot seems to be about 0.2
b1 <- butter(5, W, type = 'low')
y1 <- filtfilt(b1, xx)
sm1 <- y1[want]
antherPoll[, y][complete.cases(antherPoll[, y])] <<- sm1
})
# add time to data frame
antherPoll$tme = 0: (nrow(antherPoll) - 1) / fps # time
# add columns with absolute position into dataframe (calculated from smoothed data)
# calculate position from starting point, not from minimum point
bar = sapply(X = c("anthx.1", "anthy.1", "polx.1", "poly.1"), FUN = function(x){
newName = paste0(x, ".abs")
tmp <- antherPoll[,x] / PixInPin / 1000
antherPoll[,newName] <<- tmp - na.omit(tmp)[1]
#antherPoll[,newName] <<- tmp - min(na.omit(tmp))
})
# add columns to show velocity, based on smoothed, absolute position
# velocity is in m/s
bat = sapply(X = c("anthx.1.abs", "anthy.1.abs", "polx.1.abs", "poly.1.abs"),
FUN = function(x){
newName = paste0(x, ".vel")
tmp <-  c(NaN, diff(antherPoll[,x])) * fps # add a NaN to beginning of data
antherPoll[,newName] <<- tmp
})
# calculate speed
antherPoll$anthspeed = sqrt(antherPoll$anthx.1.abs.vel^2 + antherPoll$anthy.1.abs.vel^2)
antherPoll$polspeed = sqrt(antherPoll$polx.1.abs.vel^2 + antherPoll$poly.1.abs.vel^2)
# plot(antherPoll$anthspeed)
###########################################
# pollen acceleration
polVelocity = cbind(antherPoll$polx.1.abs.vel, antherPoll$poly.1.abs.vel)
polSpeed = antherPoll$polspeed
# plot(polSpeed)
tme = antherPoll$tme
polAccel = data.frame(rbind(c(NA, NA), apply(polVelocity, MARGIN = 2, FUN = diff))) * fps
# par(mfrow =c(2,2))
# plot(polAccel[,1], x = antherPoll$tme, type = 'l') # calculated
# plot(polAccel[,2], x = antherPoll$tme, type = 'l')
# unit tangent vector
T_t = polVelocity / polSpeed
DT = data.frame(rbind(c(NA, NA), apply(T_t, MARGIN = 2, FUN = diff))) * fps
NormDT = sqrt(DT[,1]^2 + DT[,2]^2)
Curvature = NormDT / polSpeed
# compute a_N (normal acceleration) and a_T (tangential acceleration)
# a_T = ds/dt
a_T =  c(NA, diff(polSpeed) * fps)
N_t = data.frame(t(sapply(1:nrow(DT), FUN = function(x) unlist(DT[x, ] / NormDT[x]))))
# plot(a_T, type = "l", ylim = c(-3000, 3000))
# a_N = speed^2 * curvature
a_N = polSpeed^2 * Curvature
# check total accel by adding normal and tangential accelerations
# a_total = a_T * T_t + a_N * N_t
a_total = as.data.frame(t(sapply(X = 1:nrow(polAccel), FUN  = function(x) a_T[x] * T_t[x, ] + a_N[x] * N_t[x,] )))
# plot(a_total) # includes both x and y coordinates
# plot(polAccel)
# par(mfrow = c(2,2))
# plot(unlist(a_total[,1]))
# plot(unlist(a_total[,2]))
# plot(polAccel[,1])
# plot(polAccel[,2])
# plot(a_N)
# plot(a_T)
#
a_T_Pol = a_T
# plot(a_T, x = tme)
# plot(a_N, x = tme)
# calculate magnitude of acceleration, using two methods
# 1. Normal and tangential acceleration
a_mag1 = sqrt(a_T^2 + a_N^2)
# plot(a_mag1)
amag2 = sqrt(polAccel[,1]^2 + polAccel[,2]^2)
# plot(amag2, type = 'l')
# plot(polVelocity[,1])
########################################
###########################################
# anther acceleration
anthVelocity = cbind(antherPoll$anthx.1.abs.vel, antherPoll$anthy.1.abs.vel)
anthSpeed = antherPoll$anthspeed
# plot(anthSpeed)
tme = antherPoll$tme
anthAccel = data.frame(rbind(c(NA, NA), apply(anthVelocity, MARGIN = 2, FUN = diff))) * fps
# par(mfrow =c(2,2))
# # plot(anthAccel[,1], x = antherPoll$tme, type = 'l') # calculated
# plot(anthAccel[,2], x = antherPoll$tme, type = 'l')
# unit tangent vector
T_t = anthVelocity / anthSpeed
DT = data.frame(rbind(c(NA, NA), apply(T_t, MARGIN = 2, FUN = diff))) * fps
NormDT = sqrt(DT[,1]^2 + DT[,2]^2)
Curvature = NormDT / anthSpeed
# compute a_N (normal acceleration) and a_T (tangential acceleration)
# a_T = ds/dt
a_T =  c(NA, diff(anthSpeed) * fps)
a_T_anth = a_T
N_t = data.frame(t(sapply(1:nrow(DT), FUN = function(x) unlist(DT[x, ] / NormDT[x]))))
# plot(a_T, type = "l", ylim = c(-3000, 3000))
# a_N = speed^2 * curvature
a_N = anthSpeed^2 * Curvature
# check total accel by adding normal and tangential accelerations
# a_total = a_T * T_t + a_N * N_t
a_total = as.data.frame(t(sapply(X = 1:nrow(anthAccel), FUN  = function(x) a_T[x] * T_t[x, ] + a_N[x] * N_t[x,] )))
# plot(a_total) # includes both x and y coordinates
# plot(anthAccel)
# par(mfrow = c(2,2))
# plot(unlist(a_total[,1]))
# plot(unlist(a_total[,2]))
# plot(anthAccel[,1])
# plot(anthAccel[,2])
# plot(a_N)
# plot(a_T)
# par(mfrow = c(2,1))
# plot(a_T, x = tme, type = 'l')
# max(a_T, na.rm = TRUE)
# which.max(a_T)
# plot(a_T_Pol, x = tme, type = 'l')
# max(a_T_Pol, na.rm = TRUE)
# which.max(a_T_Pol)
#
tmeRoll <- seq(from = -which(antherPoll$polStart) + 1, length.out = length(tme)) / fps
dfi <- data.frame(anthSpeed, polSpeed, a_T_anth, a_T_Pol, tme,
trial = metDat$VideoName[ii],
tmeStart = antherPoll$polStart,
tmeEnd = antherPoll$polEnd,
centeredTime = tmeRoll)
newDF <- rbind(newDF,dfi)
print(ii)
}
antherPoll$frame <- 1:nrow(antherPoll)
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3) +
geom_point(aes(x = anthx.1, y = anthy.1, colour = frame)) +
geom_path(aes(x = anthx.1, y = anthy.1, color = frame)) +
scale_color_viridis()
ggplot(na.omit(antherPoll)) +
geom_point(aes(x = anthx, y = anthy), colour = "grey", alpha = 0.3) +
geom_path(aes(x = anthx, y = anthy), color = "grey", alpha = 0.3
)
antherPoll$anthx + antherPoll$anthy
sample(c("high", "low"), 1)
file.choose()
fl <- read.csv("/Users/callinswitzer/Dropbox/ExperSummer2015/LaurelsOnly.csv")
fl$VideoName
nms <- sapply(fl$VideoName,
strsplit(fl$VideoName[1], split = ".")[[1]]
nms <- sapply(fl$VideoName,
strsplit(fl$VideoName[1], split = ".")[[1]]
nms <- sapply(fl$VideoName,
strsplit(fl$VideoName[1], split = ".")[[1]]
strsplit(fl$VideoName[1], split = ".")[[1]]
strsplit(fl$VideoName[1], split = ".")[[1]]
strsplit(fl$VideoName[1], split = "\\.")[[1]]
strsplit(as.character(fl$VideoName[1]), split = "\\.")[[1]]
strsplit(as.character(fl$VideoName[1]), split = "\\.")[[1]][1]
nms <- sapply(fl$VideoName, FUN = function(x) strsplit(as.character(x), split = "\\.")[[1]][1])
nms
dignms <- paste(nms, "xypts.csv", sep = "")
dignms
write.csv(dignms, file = "~/Desktop/dignms.csv")
file.choose()
